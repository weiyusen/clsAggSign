"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.utils=exports.schnorr=exports.verify=exports.signSync=exports.sign=exports.getSharedSecret=exports.recoverPublicKey=exports.getPublicKey=exports.Signature=exports.Point=exports.CURVE=void 0;const log=require("console")["log"],nodeCrypto=require("crypto"),_0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_3n=BigInt(3),_8n=BigInt(8),CURVE=Object.freeze({a:_0n,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:_1n,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),divNearest=(exports.CURVE=CURVE,(e,t)=>(e+t/_2n)/t),endo={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(e){var t=CURVE["n"],r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,a=BigInt("0x100000000000000000000000000000000"),s=divNearest(o*e,t),c=divNearest(-n*e,t);let u=mod(e-s*r-c*i,t),f=mod(-s*n-c*o,t);r=u>a,i=f>a;if(r&&(u=t-u),i&&(f=t-f),u>a||f>a)throw new Error("splitScalarEndo: Endomorphism failed, k="+e);return{k1neg:r,k1:u,k2neg:i,k2:f}}},fieldLen=32,groupLen=32,hashLen=32,compressedLen=fieldLen+1,uncompressedLen=2*fieldLen+1;function weierstrass(e){var{a:t,b:r}=CURVE,n=mod(e*e),n=mod(n*e);return mod(n+t*e+r)}const USE_ENDOMORPHISM=CURVE.a===_0n;class ShaError extends Error{constructor(e){super(e)}}function assertJacPoint(e){if(!(e instanceof JacobianPoint))throw new TypeError("JacobianPoint expected")}class JacobianPoint{constructor(e,t,r){this.x=e,this.y=t,this.z=r}static fromAffine(e){if(e instanceof Point)return e.equals(Point.ZERO)?JacobianPoint.ZERO:new JacobianPoint(e.x,e.y,_1n);throw new TypeError("JacobianPoint#fromAffine: expected Point")}static toAffineBatch(e){const r=invertBatch(e.map(e=>e.z));return e.map((e,t)=>e.toAffine(r[t]))}static normalizeZ(e){return JacobianPoint.toAffineBatch(e).map(JacobianPoint.fromAffine)}equals(e){assertJacPoint(e);var{x:t,y:r,z:n}=this,{x:e,y:i,z:o}=e,a=mod(n*n),s=mod(o*o),t=mod(t*s),e=mod(e*a),r=mod(mod(r*o)*s),o=mod(mod(i*n)*a);return t===e&&r===o}negate(){return new JacobianPoint(this.x,mod(-this.y),this.z)}double(){var{x:e,y:t,z:r}=this,n=mod(e*e),i=mod(t*t),o=mod(i*i),e=e+i,i=mod(_2n*(mod(e*e)-n-o)),e=mod(_3n*n),n=mod(e*e),n=mod(n-_2n*i),e=mod(e*(i-n)-_8n*o),i=mod(_2n*t*r);return new JacobianPoint(n,e,i)}add(e){assertJacPoint(e);var t,{x:r,y:n,z:i}=this,{x:o,y:a,z:s}=e;return o===_0n||a===_0n?this:r===_0n||n===_0n?e:(e=mod(i*i),t=mod(s*s),r=mod(r*t),o=mod(o*e),n=mod(mod(n*s)*t),t=mod(mod(a*i)*e),a=mod(o-r),e=mod(t-n),a===_0n?e===_0n?this.double():JacobianPoint.ZERO:(o=mod(a*a),t=mod(a*o),r=mod(r*o),o=mod(e*e-t-_2n*r),e=mod(e*(r-o)-n*t),r=mod(i*s*a),new JacobianPoint(o,e,r)))}subtract(e){return this.add(e.negate())}multiplyUnsafe(e){var r=JacobianPoint.ZERO;if("bigint"==typeof e&&e===_0n)return r;let n=normalizeScalar(e);if(n===_1n)return this;if(!USE_ENDOMORPHISM){let e=r,t=this;for(;n>_0n;)n&_1n&&(e=e.add(t)),t=t.double(),n>>=_1n;return e}let{k1neg:t,k1:i,k2neg:o,k2:a}=endo.splitScalar(n),s=r,c=r,u=this;for(;i>_0n||a>_0n;)i&_1n&&(s=s.add(u)),a&_1n&&(c=c.add(u)),u=u.double(),i>>=_1n,a>>=_1n;return t&&(s=s.negate()),o&&(c=c.negate()),c=new JacobianPoint(mod(c.x*endo.beta),c.y,c.z),s.add(c)}precomputeWindow(t){var r=USE_ENDOMORPHISM?128/t+1:256/t+1,n=[];let i=this,o=i;for(let e=0;e<r;e++){o=i,n.push(o);for(let e=1;e<2**(t-1);e++)o=o.add(i),n.push(o);i=o.double()}return n}wNAF(r,e){var t=(e=!e&&this.equals(JacobianPoint.BASE)?Point.BASE:e)&&e._WINDOW_SIZE||1;if(256%t)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=e&&pointPrecomputes.get(e),i=(n||(n=this.precomputeWindow(t),e&&1!==t&&(n=JacobianPoint.normalizeZ(n),pointPrecomputes.set(e,n))),JacobianPoint.ZERO),o=JacobianPoint.BASE;var a=1+(USE_ENDOMORPHISM?128/t:256/t),s=2**(t-1),c=BigInt(2**t-1),u=2**t,f=BigInt(t);for(let t=0;t<a;t++){var y=t*s;let e=Number(r&c);r>>=f,e>s&&(e-=u,r+=_1n);var l=y,y=y+Math.abs(e)-1,h=t%2!=0,d=e<0;0===e?o=o.add(constTimeNegate(h,n[l])):i=i.add(constTimeNegate(d,n[y]))}return{p:i,f:o}}multiply(e,t){var r,n,i,o,a,s,e=normalizeScalar(e);let c,u;return u=USE_ENDOMORPHISM?({k1neg:a,k1:i,k2neg:s,k2:o}=endo.splitScalar(e),{p:i,f:r}=this.wNAF(i,t),{p:o,f:n}=this.wNAF(o,t),i=constTimeNegate(a,i),o=constTimeNegate(s,o),o=new JacobianPoint(mod(o.x*endo.beta),o.y,o.z),c=i.add(o),r.add(n)):({p:a,f:s}=this.wNAF(e,t),c=a,s),JacobianPoint.normalizeZ([c,u])[0]}toAffine(e){var{x:t,y:r,z:n}=this,i=this.equals(JacobianPoint.ZERO),e=e=null==e?i?_8n:invert(n):e,o=mod(e*e),a=mod(o*e),t=mod(t*o),o=mod(r*a),r=mod(n*e);if(i)return Point.ZERO;if(r!==_1n)throw new Error("invZ was invalid");return new Point(t,o)}}function constTimeNegate(e,t){var r=t.negate();return e?r:t}JacobianPoint.BASE=new JacobianPoint(CURVE.Gx,CURVE.Gy,_1n),JacobianPoint.ZERO=new JacobianPoint(_0n,_1n,_0n);const pointPrecomputes=new WeakMap;class Point{constructor(e,t){this.x=e,this.y=t}_setWindowSize(e){this._WINDOW_SIZE=e,pointPrecomputes.delete(this)}hasEvenY(){return this.y%_2n===_0n}static fromCompressedHex(e){var t=32===e.length,r=bytesToNumber(t?e:e.subarray(1));if(!isValidFieldElement(r))throw new Error("Point is not on curve");let n=sqrtMod(weierstrass(r));var i=(n&_1n)===_1n,t=(t?i&&(n=mod(-n)):1==(1&e[0])!=i&&(n=mod(-n)),new Point(r,n));return t.assertValidity(),t}static fromUncompressedHex(e){var t=bytesToNumber(e.subarray(1,fieldLen+1)),e=bytesToNumber(e.subarray(fieldLen+1,2*fieldLen+1)),t=new Point(t,e);return t.assertValidity(),t}static fromHex(e){var e=ensureBytes(e),t=e.length,r=e[0];if(t===fieldLen)return this.fromCompressedHex(e);if(t===compressedLen&&(2===r||3===r))return this.fromCompressedHex(e);if(t===uncompressedLen&&4===r)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not `+t)}static fromPrivateKey(e){return Point.BASE.multiply(normalizePrivateKey(e))}static fromSignature(e,t,r){var{r:t,s:n}=normalizeSignature(t);if(![0,1,2,3].includes(r))throw new Error("Cannot recover: invalid recovery bit");var e=truncateHash(ensureBytes(e)),i=CURVE["n"],t=2===r||3===r?t+i:t,o=invert(t,i),e=mod(-e*o,i),n=mod(n*o,i),o=1&r?"03":"02",i=Point.fromHex(o+numTo32bStr(t)),r=Point.BASE.multiplyAndAddUnsafe(i,e,n);if(r)return r.assertValidity(),r;throw new Error("Cannot recover signature: point at infinify")}toRawBytes(e=!1){return hexToBytes(this.toHex(e))}toHex(e=!1){var t=numTo32bStr(this.x);return e?(this.hasEvenY()?"02":"03")+t:"04"+t+numTo32bStr(this.y)}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){var e="Point is not on elliptic curve",{x:t,y:r}=this;if(!isValidFieldElement(t)||!isValidFieldElement(r))throw new Error(e);r=mod(r*r);if(mod(r-weierstrass(t))!==_0n)throw new Error(e)}equals(e){return this.x===e.x&&this.y===e.y}negate(){return new Point(this.x,mod(-this.y))}double(){return JacobianPoint.fromAffine(this).double().toAffine()}add(e){return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(e)).toAffine()}subtract(e){return this.add(e.negate())}multiply(e){return JacobianPoint.fromAffine(this).multiply(e,this).toAffine()}multiplyAndAddUnsafe(e,t,r){var n=JacobianPoint.fromAffine(this),n=t===_0n||t===_1n||this!==Point.BASE?n.multiplyUnsafe(t):n.multiply(t),t=JacobianPoint.fromAffine(e).multiplyUnsafe(r),e=n.add(t);return e.equals(JacobianPoint.ZERO)?void 0:e.toAffine()}}function sliceDER(e){return 8<=Number.parseInt(e[0],16)?"00"+e:e}function parseDERInt(e){if(e.length<2||2!==e[0])throw new Error("Invalid signature integer tag: "+bytesToHex(e));var t=e[1],r=e.subarray(2,t+2);if(!t||r.length!==t)throw new Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:bytesToNumber(r),left:e.subarray(t+2)}}function parseDERSignature(e){if(e.length<2||48!=e[0])throw new Error("Invalid signature tag: "+bytesToHex(e));if(e[1]!==e.length-2)throw new Error("Invalid signature: incorrect length");var{data:e,left:t}=parseDERInt(e.subarray(2)),{data:t,left:r}=parseDERInt(t);if(r.length)throw new Error("Invalid signature: left bytes after parsing: "+bytesToHex(r));return{r:e,s:t}}(exports.Point=Point).BASE=new Point(CURVE.Gx,CURVE.Gy),Point.ZERO=new Point(_0n,_0n);class Signature{constructor(e,t){this.r=e,this.s=t,this.assertValidity()}static fromCompact(e){var t=e instanceof Uint8Array,r="Signature.fromCompact";if("string"!=typeof e&&!t)throw new TypeError(r+": Expected string or Uint8Array");t=t?bytesToHex(e):e;if(128!==t.length)throw new Error(r+": Expected 64-byte hex");return new Signature(hexToNumber(t.slice(0,64)),hexToNumber(t.slice(64,128)))}static fromDER(e){var t=e instanceof Uint8Array;if("string"==typeof e||t)return{r:t,s:e}=parseDERSignature(t?e:hexToBytes(e)),new Signature(t,e);throw new TypeError("Signature.fromDER: Expected string or Uint8Array")}static fromHex(e){return this.fromDER(e)}assertValidity(){var{r:e,s:t}=this;if(!isWithinCurveOrder(e))throw new Error("Invalid Signature: r must be 0 < r < n");if(!isWithinCurveOrder(t))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){var e=CURVE.n>>_1n;return this.s>e}normalizeS(){return this.hasHighS()?new Signature(this.r,mod(-this.s,CURVE.n)):this}toDERRawBytes(){return hexToBytes(this.toDERHex())}toDERHex(){var e=sliceDER(numberToHexUnpadded(this.s)),t=sliceDER(numberToHexUnpadded(this.r)),r=e.length/2,n=t.length/2,i=numberToHexUnpadded(r),o=numberToHexUnpadded(n);return`30${numberToHexUnpadded(n+r+4)}02${o}${t}02`+i+e}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return numTo32bStr(this.r)+numTo32bStr(this.s)}}function concatBytes(...r){if(!r.every(e=>e instanceof Uint8Array))throw new Error("Uint8Array list expected");if(1===r.length)return r[0];var e=r.reduce((e,t)=>e+t.length,0),n=new Uint8Array(e);for(let e=0,t=0;e<r.length;e++){var i=r[e];n.set(i,t),t+=i.length}return n}exports.Signature=Signature;const hexes=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function bytesToHex(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let r="";for(let e=0;e<t.length;e++)r+=hexes[t[e]];return r}const POW_2_256=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function numTo32bStr(e){if("bigint"!=typeof e)throw new Error("Expected bigint");if(_0n<=e&&e<POW_2_256)return e.toString(16).padStart(64,"0");throw new Error("Expected number 0 <= n < 2^256")}function numTo32b(e){e=hexToBytes(numTo32bStr(e));if(32!==e.length)throw new Error("Error: expected 32 bytes");return e}function numberToHexUnpadded(e){e=e.toString(16);return 1&e.length?"0"+e:e}function hexToNumber(e){if("string"!=typeof e)throw new TypeError("hexToNumber: expected string, got "+typeof e);return BigInt("0x"+e)}function hexToBytes(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);var r=new Uint8Array(t.length/2);for(let e=0;e<r.length;e++){var n=2*e,n=t.slice(n,2+n),n=Number.parseInt(n,16);if(Number.isNaN(n)||n<0)throw new Error("Invalid byte sequence");r[e]=n}return r}function bytesToNumber(e){return hexToNumber(bytesToHex(e))}function ensureBytes(e){return e instanceof Uint8Array?Uint8Array.from(e):hexToBytes(e)}function normalizeScalar(e){if("number"==typeof e&&Number.isSafeInteger(e)&&0<e)return BigInt(e);if("bigint"==typeof e&&isWithinCurveOrder(e))return e;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function mod(e,t=CURVE.P){e%=t;return e>=_0n?e:t+e}function pow2(e,t){var r=CURVE["P"];let n=e;for(;t-- >_0n;)n=n*n%r;return n}function sqrtMod(e){var t=CURVE["P"],r=BigInt(6),n=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),s=BigInt(88),c=e*e*e%t,u=c*c*e%t,f=pow2(u,_3n)*u%t,f=pow2(f,_3n)*u%t,f=pow2(f,_2n)*c%t,n=pow2(f,n)*f%t,f=pow2(n,i)*n%t,i=pow2(f,a)*f%t,s=pow2(i,s)*i%t,i=pow2(s,a)*f%t,s=pow2(i,_3n)*u%t,a=pow2(s,o)*n%t,f=pow2(a,r)*c%t,i=pow2(f,_2n);if(i*i%t!==e)throw new Error("Cannot find square root");return i}function invert(e,t=CURVE.P){if(e===_0n||t<=_0n)throw new Error(`invert: expected positive integers, got n=${e} mod=`+t);let r=mod(e,t),n=t,i=_0n,o=_1n,a=_1n,s=_0n;for(;r!==_0n;){var c=n/r,u=n%r,f=i-a*c,c=o-s*c;n=r,r=u,i=a,o=s,a=f,s=c}if(n!==_1n)throw new Error("invert: does not exist");return mod(i,t)}function invertBatch(e,n=CURVE.P){const i=new Array(e.length);var t=invert(e.reduce((e,t,r)=>t===_0n?e:mod((i[r]=e)*t,n),_1n),n);return e.reduceRight((e,t,r)=>t===_0n?e:(i[r]=mod(e*i[r],n),mod(e*t,n)),t),i}function bits2int_2(e){var t=8*e.length-8*groupLen,e=bytesToNumber(e);return 0<t?e>>BigInt(t):e}function truncateHash(e,t=!1){e=bits2int_2(e);return!t&&(t=CURVE.n,t<=e)?e-t:e}let _sha256Sync,_hmacSha256Sync;class HmacDrbg{constructor(e,t){if(this.hashLen=e,this.qByteLen=t,"number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(e).fill(1),this.k=new Uint8Array(e).fill(0),this.counter=0}hmac(...e){return exports.utils.hmacSha256(this.k,...e)}hmacSync(...e){return _hmacSha256Sync(this.k,...e)}checkSync(){if("function"!=typeof _hmacSha256Sync)throw new ShaError("hmacSha256Sync needs to be set")}incr(){if(1e3<=this.counter)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(e=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),e),this.v=await this.hmac(this.v),0!==e.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),e),this.v=await this.hmac(this.v))}reseedSync(e=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),e),this.v=this.hmacSync(this.v),0!==e.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),e),this.v=this.hmacSync(this.v))}async generate(){this.incr();let e=0;for(var t=[];e<this.qByteLen;){this.v=await this.hmac(this.v);var r=this.v.slice();t.push(r),e+=this.v.length}return concatBytes(...t)}generateSync(){this.checkSync(),this.incr();let e=0;for(var t=[];e<this.qByteLen;){this.v=this.hmacSync(this.v);var r=this.v.slice();t.push(r),e+=this.v.length}return concatBytes(...t)}}function isWithinCurveOrder(e){return _0n<e&&e<CURVE.n}function isValidFieldElement(e){return _0n<e&&e<CURVE.P}function kmdToSig(r,e,t,n=!0){var i=CURVE["n"],r=truncateHash(r,!0);if(isWithinCurveOrder(r)){var o=invert(r,i),r=Point.BASE.multiply(r),a=mod(r.x,i);if(a!==_0n){o=mod(o*mod(e+t*a,i),i);if(o!==_0n){let e=new Signature(a,o),t=(r.x===e.r?0:2)|Number(r.y&_1n);return n&&e.hasHighS()&&(e=e.normalizeS(),t^=1),{sig:e,recovery:t}}}}}function normalizePrivateKey(e){let t;if("bigint"==typeof e)t=e;else if("number"==typeof e&&Number.isSafeInteger(e)&&0<e)t=BigInt(e);else if("string"==typeof e){if(e.length!==2*groupLen)throw new Error("Expected 32 bytes of private key");t=hexToNumber(e)}else{if(!(e instanceof Uint8Array))throw new TypeError("Expected valid private key");if(e.length!==groupLen)throw new Error("Expected 32 bytes of private key");t=bytesToNumber(e)}if(isWithinCurveOrder(t))return t;throw new Error("Expected private key: 0 < key < n")}function normalizePublicKey(e){return e instanceof Point?(e.assertValidity(),e):Point.fromHex(e)}function normalizeSignature(t){if(t instanceof Signature)return t.assertValidity(),t;try{return Signature.fromDER(t)}catch(e){return Signature.fromCompact(t)}}function getPublicKey(e,t=!1){return Point.fromPrivateKey(e).toRawBytes(t)}function recoverPublicKey(e,t,r,n=!1){return Point.fromSignature(e,t,r).toRawBytes(n)}function isProbPub(e){var t=e instanceof Uint8Array,r="string"==typeof e,n=(t||r)&&e.length;return t?n===compressedLen||n===uncompressedLen:r?n===2*compressedLen||n===2*uncompressedLen:e instanceof Point}function getSharedSecret(e,t,r=!1){if(isProbPub(e))throw new TypeError("getSharedSecret: first arg must be private key");if(isProbPub(t))return(t=normalizePublicKey(t)).assertValidity(),t.multiply(normalizePrivateKey(e)).toRawBytes(r);throw new TypeError("getSharedSecret: second arg must be public key")}function bits2int(e){return bytesToNumber(e.length>fieldLen?e.slice(0,fieldLen):e)}function bits2octets(e){var e=bits2int(e),t=mod(e,CURVE.n);return int2octets(t<_0n?e:t)}function int2octets(e){return numTo32b(e)}function initSigArgs(e,t,r){if(null==e)throw new Error(`sign: expected valid message hash, not "${e}"`);var e=ensureBytes(e),t=normalizePrivateKey(t),n=[int2octets(t),bits2octets(e)];if(null!=r){r=ensureBytes(r=!0===r?exports.utils.randomBytes(fieldLen):r);if(r.length!==fieldLen)throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);n.push(r)}return{seed:concatBytes(...n),m:bits2int(e),d:t}}function finalizeSig(e,t){var{sig:e,recovery:r}=e,{der:t,recovered:n}=Object.assign({canonical:!0,der:!0},t),t=t?e.toDERRawBytes():e.toCompactRawBytes();return n?[t,r]:t}async function sign(e,t,r={}){var{seed:e,m:n,d:i}=initSigArgs(e,t,r.extraEntropy),o=new HmacDrbg(hashLen,groupLen);await o.reseed(e);let a;for(;!(a=kmdToSig(await o.generate(),n,i,r.canonical));)await o.reseed();return finalizeSig(a,r)}function signSync(e,t,r={}){var{seed:e,m:n,d:i}=initSigArgs(e,t,r.extraEntropy),o=new HmacDrbg(hashLen,groupLen);o.reseedSync(e);let a;for(;!(a=kmdToSig(o.generateSync(),n,i,r.canonical));)o.reseedSync();return finalizeSig(a,r)}exports.getPublicKey=getPublicKey,exports.recoverPublicKey=recoverPublicKey,exports.getSharedSecret=getSharedSecret,exports.sign=sign,exports.signSync=signSync;const vopts={strict:!0};function verify(e,t,r,n=vopts){let i;try{i=normalizeSignature(e),t=ensureBytes(t)}catch(e){return!1}var{r:e,s:o}=i;if(n.strict&&i.hasHighS())return!1;n=truncateHash(t);let a;try{a=normalizePublicKey(r)}catch(e){return!1}t=CURVE.n,r=invert(o,t),o=mod(n*r,t),n=mod(e*r,t),r=Point.BASE.multiplyAndAddUnsafe(a,o,n);return!!r&&mod(r.x,t)===e}function schnorrChallengeFinalize(e){return mod(bytesToNumber(e),CURVE.n)}exports.verify=verify;class SchnorrSignature{constructor(e,t){this.r=e,this.s=t,this.assertValidity()}static fromHex(e){e=ensureBytes(e);if(64!==e.length)throw new TypeError("SchnorrSignature.fromHex: expected 64 bytes, not "+e.length);var t=bytesToNumber(e.subarray(0,32)),e=bytesToNumber(e.subarray(32,64));return new SchnorrSignature(t,e)}assertValidity(){var{r:e,s:t}=this;if(!isValidFieldElement(e)||!isWithinCurveOrder(t))throw new Error("Invalid signature")}toHex(){return numTo32bStr(this.r)+numTo32bStr(this.s)}toRawBytes(){return hexToBytes(this.toHex())}}function schnorrGetPublicKey(e){return Point.fromPrivateKey(e).toRawX()}class InternalSchnorrSignature{constructor(e,t,r=exports.utils.randomBytes()){if(null==e)throw new TypeError(`sign: Expected valid message, not "${e}"`);this.m=ensureBytes(e);var{x:e,scalar:t}=this.getScalar(normalizePrivateKey(t));if(this.px=e,this.d=t,this.rand=ensureBytes(r),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(e){var t=Point.fromPrivateKey(e),e=t.hasEvenY()?e:CURVE.n-e;return{point:t,scalar:e,x:t.toRawX()}}initNonce(e,t){return numTo32b(e^bytesToNumber(t))}finalizeNonce(e){e=mod(bytesToNumber(e),CURVE.n);if(e===_0n)throw new Error("sign: Creation of signature failed. k is zero");var{point:e,x:t,scalar:r}=this.getScalar(e);return{R:e,rx:t,k:r}}finalizeSig(e,t,r,n){return new SchnorrSignature(e.x,mod(t+r*n,CURVE.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){var{m:e,d:t,px:r,rand:n}=this,i=exports.utils.taggedHash,n=this.initNonce(t,await i(TAGS.aux,n)),{R:n,rx:o,k:a}=this.finalizeNonce(await i(TAGS.nonce,n,r,e)),i=schnorrChallengeFinalize(await i(TAGS.challenge,o,r,e)),o=this.finalizeSig(n,a,i,t);return await schnorrVerify(o,e,r)||this.error(),o}calcSync(){var{m:e,d:t,px:r,rand:n}=this,i=exports.utils.taggedHashSync,n=this.initNonce(t,i(TAGS.aux,n)),{R:n,rx:o,k:a}=this.finalizeNonce(i(TAGS.nonce,n,r,e)),i=schnorrChallengeFinalize(i(TAGS.challenge,o,r,e)),o=this.finalizeSig(n,a,i,t);return schnorrVerifySync(o,e,r)||this.error(),o}}async function schnorrSign(e,t,r){return new InternalSchnorrSignature(e,t,r).calc()}function schnorrSignSync(e,t,r){return new InternalSchnorrSignature(e,t,r).calcSync()}function initSchnorrVerify(e,t,r){var n=e instanceof SchnorrSignature,e=n?e:SchnorrSignature.fromHex(e);return n&&e.assertValidity(),{...e,m:ensureBytes(t),P:normalizePublicKey(r)}}function finalizeSchnorrVerify(e,t,r,n){t=Point.BASE.multiplyAndAddUnsafe(t,normalizePrivateKey(r),mod(-n,CURVE.n));return!(!t||!t.hasEvenY()||t.x!==e)}async function schnorrVerify(e,t,r){try{var{r:n,s:i,m:o,P:a}=initSchnorrVerify(e,t,r),s=schnorrChallengeFinalize(await exports.utils.taggedHash(TAGS.challenge,numTo32b(n),a.toRawX(),o));return finalizeSchnorrVerify(n,a,i,s)}catch(e){return!1}}function schnorrVerifySync(e,t,r){try{var{r:n,s:i,m:o,P:a}=initSchnorrVerify(e,t,r),s=schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge,numTo32b(n),a.toRawX(),o));return finalizeSchnorrVerify(n,a,i,s)}catch(e){if(e instanceof ShaError)throw e;return!1}}exports.schnorr={Signature:SchnorrSignature,getPublicKey:schnorrGetPublicKey,sign:schnorrSign,verify:schnorrVerify,signSync:schnorrSignSync,verifySync:schnorrVerifySync},Point.BASE._setWindowSize(8);const crypto={node:nodeCrypto,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},TAGS={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},TAGGED_HASH_PREFIXES={};function certificatelessGetPublicKey(e){return Point.fromPrivateKey(e).toRawBytes(!1)}async function certificatelessGetPartialKey(e,t,r){var n=exports.utils.randomPrivateKey(),i=normalizePublicKey(certificatelessGetPublicKey(n)),t=normalizePublicKey(t),o=normalizePublicKey(Point.fromPrivateKey(r)).toRawBytes(!1),a=JacobianPoint.fromAffine(i),t=JacobianPoint.fromAffine(t),a=a.add(t).toAffine().toRawBytes(!1),t=mod(bytesToNumber(await exports.utils.sha256(e,a,o)),CURVE.n);return{partialSecretKeyArray:numTo32b(mod(bytesToNumber(n)+t*bytesToNumber(r),CURVE.n)),NPointArray:i.toRawBytes(!1)}}function certificatelessSetPublicKey(e,t){t=normalizePublicKey(t),e=normalizePublicKey(e);return JacobianPoint.fromAffine(e).add(JacobianPoint.fromAffine(t)).toAffine().toRawBytes(!1)}async function verifyPartialKey(e,t,r,n,i){var e=bytesToNumber(e),e=normalizePublicKey(Point.BASE.multiply(e)),t=normalizePublicKey(t),o=normalizePublicKey(n).toRawBytes(!1),i=mod(bytesToNumber(await exports.utils.sha256(i,t.toRawBytes(!1),o)),CURVE.n),t=JacobianPoint.fromAffine(normalizePublicKey(n)).multiply(i),o=JacobianPoint.fromAffine(normalizePublicKey(r)).add(t).toAffine();return e.x===o.x&&e.y===o.y?"success":"false"}async function certificatelessSign(e,t,r,n,i,o){var e=bytesToNumber(e),t=bytesToNumber(t),n=normalizePublicKey(n),a=bytesToNumber(exports.utils.randomPrivateKey()),s=normalizePublicKey(Point.fromPrivateKey(a)),i=normalizePublicKey(i),r=mod(bytesToNumber(await exports.utils.sha256(r,n.toRawBytes(!1),i.toRawBytes(!1),o,s.toRawBytes(!1))),CURVE.n);return{certificatelessSignatutreArray:numTo32b(mod(e+t+r*a,CURVE.n)),UPointArray:s.toRawBytes(!1)}}async function certificatelessVerify(e,t,r,n,i,o){var e=bytesToNumber(e),e=normalizePublicKey(Point.BASE.multiply(e)),r=normalizePublicKey(r),o=normalizePublicKey(o),n=normalizePublicKey(n),a=mod(bytesToNumber(await exports.utils.sha256(t,r.toRawBytes(!1),n.toRawBytes(!1))),CURVE.n),a=JacobianPoint.fromAffine(n).multiply(a),t=mod(bytesToNumber(await exports.utils.sha256(t,r.toRawBytes(!1),n.toRawBytes(!1),i,o.toRawBytes(!1))),CURVE.n),n=JacobianPoint.fromAffine(o).multiply(t),i=JacobianPoint.fromAffine(r).add(n).add(a).toAffine();return e.x===i.x&&e.y===i.y?"success":"false"}async function certificatelessAggSign(t,e,r,n,i,o){var a=Uint8ArrayAgg(e),s=Uint8ArrayAgg(n),c=Uint8ArrayAgg(r),u=Uint8ArrayAgg(i);let f=_0n;for(let e=0;e<t.length;e++){var y=mod(bytesToNumber(await exports.utils.sha256(u,a,s,c,o,new Uint8Array(e))),CURVE.n);f+=y*bytesToNumber(t[e])}return numTo32b(mod(f,CURVE.n))}async function certificatelessAggVerify(e,t,r,n,i,o){var e=bytesToNumber(e),e=normalizePublicKey(Point.BASE.multiply(e)),a=Uint8ArrayAgg(t),s=Uint8ArrayAgg(n),c=Uint8ArrayAgg(r),u=Uint8ArrayAgg(i),f=[];for(let e=0;e<t.length;e++){var y=mod(bytesToNumber(await exports.utils.sha256(i[e],n[e],o)),CURVE.n),y=JacobianPoint.fromAffine(normalizePublicKey(o)).multiply(y),l=mod(bytesToNumber(await exports.utils.sha256(i[e],n[e],o,r[e],t[e])),CURVE.n),l=JacobianPoint.fromAffine(normalizePublicKey(t[e])).multiply(l),h=mod(bytesToNumber(await exports.utils.sha256(u,a,s,c,o,new Uint8Array(e))),CURVE.n),l=JacobianPoint.fromAffine(normalizePublicKey(n[e])).add(l).add(y).multiply(h);f.push(l)}var d=f.reduce((e,t)=>e.add(t)).toAffine();return e.x===d.x&&e.y===d.y?"success":"false"}function Uint8ArrayAgg(e){e=e.reduce((e,t)=>(e.push(...t),e),[]);return new Uint8Array(e)}exports.utils={bytesToHex:bytesToHex,hexToBytes:hexToBytes,concatBytes:concatBytes,mod:mod,invert:invert,isValidPrivateKey(e){try{return normalizePrivateKey(e),!0}catch(e){return!1}},_bigintTo32Bytes:numTo32b,_normalizePrivateKey:normalizePrivateKey,hashToPrivateKey:e=>{e=ensureBytes(e);var t=groupLen+8;if(e.length<t||1024<e.length)throw new Error("Expected valid bytes of private key as per FIPS 186");return numTo32b(mod(bytesToNumber(e),CURVE.n-_1n)+_1n)},randomBytes:(e=32)=>{if(crypto.web)return crypto.web.getRandomValues(new Uint8Array(e));var t;if(crypto.node)return t=crypto.node["randomBytes"],Uint8Array.from(t(e));throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>exports.utils.hashToPrivateKey(exports.utils.randomBytes(groupLen+8)),randomPID:()=>exports.utils.randomPrivateKey(),precompute(e=8,t=Point.BASE){t=t===Point.BASE?t:new Point(t.x,t.y);return t._setWindowSize(e),t.multiply(_3n),t},sha256:async(...e)=>{if(crypto.web)return t=await crypto.web.subtle.digest("SHA-256",concatBytes(...e)),new Uint8Array(t);if(crypto.node){var t=crypto.node["createHash"];const r=t("sha256");return e.forEach(e=>r.update(e)),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(e,...t)=>{var r;if(crypto.web)return r=await crypto.web.subtle.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=concatBytes(...t),r=await crypto.web.subtle.sign("HMAC",r,n),new Uint8Array(r);if(crypto.node){var n=crypto.node["createHmac"];const i=n("sha256",e);return t.forEach(e=>i.update(e)),Uint8Array.from(i.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(e,...t)=>{let r=TAGGED_HASH_PREFIXES[e];var n;return void 0===r&&(n=await exports.utils.sha256(Uint8Array.from(e,e=>e.charCodeAt(0))),r=concatBytes(n,n),TAGGED_HASH_PREFIXES[e]=r),exports.utils.sha256(r,...t)},taggedHashSync:(e,...t)=>{if("function"!=typeof _sha256Sync)throw new ShaError("sha256Sync is undefined, you need to set it");let r=TAGGED_HASH_PREFIXES[e];var n;return void 0===r&&(n=_sha256Sync(Uint8Array.from(e,e=>e.charCodeAt(0))),r=concatBytes(n,n),TAGGED_HASH_PREFIXES[e]=r),_sha256Sync(r,...t)},_JacobianPoint:JacobianPoint},Object.defineProperties(exports.utils,{sha256Sync:{configurable:!1,get(){return _sha256Sync},set(e){_sha256Sync=_sha256Sync||e}},hmacSha256Sync:{configurable:!1,get(){return _hmacSha256Sync},set(e){_hmacSha256Sync=_hmacSha256Sync||e}}}),exports.certificateless={getPublicKey:certificatelessGetPublicKey,getPartialKey:certificatelessGetPartialKey,setPublicKey:certificatelessSetPublicKey,verifyPartialKey:verifyPartialKey,certificatelessSign:certificatelessSign,certificatelessVerify:certificatelessVerify,certificatelessAggSign:certificatelessAggSign,certificatelessAggVerify:certificatelessAggVerify};